<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
<head>
<title>Evolve 4.0 - Organisms and Cells</title>
<!--Change this href to "msfunk_03.css" to give the page a different look!-->
<link rel="stylesheet" type="text/css" href="msfunk_02.css" />

</head>
<body>
<!--Begin headers-->
<div id="title2" class="title2">
<B>Last updated:</B> May 6, 2007
</div>

<div id="title3" class="title3">
<a name="title">Evolve 4.0 - Organisms and Cells</a>
</div>


<div id="subnav" class="subnav">
<a href="http://www.stauffercom.com/evolve4/evolve4exe.zip">Download Executable</a> | 
<a href="http://www.stauffercom.com/evolve4/evolve4src.zip">Download Source</a> |
<a href="contents.html">User Manual</a>
</div>
<!--End headers-->

<!--Begin nav-->
<div id="menu">

<p class="menu"><a href="index.html">Home</a></p>
<p class="menu"><a href="screen_shots.html">Screen Shots</a></p>
<p class="menu"><a href="overview.html">Overview</a></p>
<p class="menu"><a href="getting_started.html">Getting Started</a></p>
<p class="menu"><a href="organisms.html">Organisms and Cells</a></p>
<p class="menu"><a href="spores.html">Spores</a></p>
<p class="menu"><a href="genetics.html">Genetics</a></p>
<p class="menu"><a href="mutations.html">Mutations/Replication</a></p>
<p class="menu"><a href="kforth.html">KFORTH Language</a></p>
<p class="menu"><a href="faq.html">FAQ</a></p>
<p class="menu"><a href="contact.html">Contact Me</a></p>
<p class="menu"><a href="links.html">Links</a></p>

</div>


<!--End nav-->

<!--Begin main text-->
<div id="maintext" height="600px">

<IMG SRC="e.gif"><B><FONT SIZE=5>VOLVE</FONT> &nbsp;&nbsp; <FONT SIZE=6>4.0</FONT></B>

<h1>Organisms and Cells</h1>
This page will discusss the mechanics of how cells and organism interact
with the universe.
<P>
<B>Table of Contents:</B>
<UL>
<LI> <A HREF="#directions">Direction Vectors</A>
<LI> <A HREF="#normalized_vectors">Normalized Vectors</A>
<LI> <A HREF="#connectivity">Organism Connectivity</A>
<LI> <A HREF="#energy">Energy</A>
<LI> <A HREF="#omove">Instruction: <B>OMOVE</B></A>
<LI> <A HREF="#rotate">Instruction: <B>ROTATE</B></A>
<LI> <A HREF="#cmove">Instruction: <B>CMOVE</B></A>
<LI> <A HREF="#grow">Instruction: <B>GROW</B></A>
<LI> <A HREF="#make-spore">Instruction: <B>MAKE-SPORE</B></A>
<LI> <A HREF="#eat">Instruction: <B>EAT</B></A>
<LI> <A HREF="#look">Instruction: <B>LOOK</B></A>
<LI> <A HREF="#what">Instruction: <B>WHAT</B></A>
<LI> <A HREF="#where">Instruction: <B>WHERE</B></A>
<LI> <A HREF="#nearest">Instruction: <B>NEAREST</B></A>
<LI> <A HREF="#farthest">Instruction: <B>FARTHEST</B></A>
<LI> <A HREF="#nearest2">Instruction: <B>NEAREST2</B></A>
<LI> <A HREF="#farthest2">Instruction: <B>FARTHEST2</B></A>
<LI> <A HREF="#reference">Organism Instruction Reference</A>
<LI> <A HREF="#cellular_communications">Communicating Between Cells</A>
</UL>

<HR>

<A NAME="directions">
<H2>Directions</H2>
Many of the instructions that cells execute require a vector. This vector
is used to indicate a direction, or an adjacent square that the organism or
cell will interact with. This diagram shows (x, y) coordinates for
the eight directions surrounding a cell:
<P>
<CENTER><IMG SRC="directions.gif"></CENTER>
<P>
All operations that interact with the universe using (x, y) coordinates will specify coordinates
like these.
<P>

<HR>

<A NAME="normalized_vectors">
<H2>Normalized Vectors</H2>
Most operations are restricted to the adjacent squares
Therefore, Evolve normalizes all coordinates to values of -1, 0, +1.

<P>
<UL>
<LI> <B>values less than 0 (&lt; 0) </B> => map to -1.
<LI> <B>values equal to 0 (= 0)</B> => map to 0.
<LI> <B>values more than 0 (&gt; 0) </B> => map to 1.
</UL>
<P>
For example,
<PRE>
	-30  4   OMOVE		; move organism using vector (-1, 1)
	  0 -4   CMOVE		; move cell using vector (0, -1)
	  9 29 5 MAKE-SPORE	; make spore using vector (1, 1) (with energy 5)
</PRE>
<P>

<HR>

<A NAME="connectivity">
<H2>Organism Connectivity</H2>
Organisms consists of one or more cells. To ensure the shape of
an organism remains coherent (i.e, sane) Evolve will enforce certain connectivity
constraints.
<P>
Consider this organism,
<P>
<IMG SRC="connect1.gif">
<P>
One of its corner cells has been killed,
<P>
<IMG SRC="connect2.gif">
<P>
Our connectivity constraints are such that a multi-cellular organism must always have at least
one neighbor in the up, down, left or right location. <B>A diagonal neighbor is
not sufficient</B>.
<P>
Therefore in this example, after the dead cell is removed, we have to
make the organism properly connected. We do this by killing off one of
the regions.
<P>
To resolve this problem, we analyse the organism and kill off the <B>smallest regions</B>. Keeping
just the largest section. In the event of a "tie" we just choose the first region
that our traversal algorithm considered.
<P>
<IMG SRC="connect3.gif">
<P>
The "L" shaped region had the smaller number of cells, so it was killed off. This
is how "organic material" gets created. It is left over material from such interactions.
Each white square has a fraction of the original organisms energy amount.
<P>
Let's look at another example:
<P>
<IMG SRC="connect4.gif">
<P>
In this case the death of this cell does not break the organism into multiple sections.
So in this case we just kill of the cell in question.
<P>
<IMG SRC="connect5.gif">
<P>

The following are examples of bogus organisms:
<P>
<IMG SRC="organism_bad1.gif">
<P>
This is bogus because cell 2 doesn't connect to cell 4. And cell 4 doesn't
connect to cell 5.
<P>
<IMG SRC="organism_bad2.gif">
<P>
This organism is bogus because cell 1 doesn't connect to cell 3. The
rest of the organism is okay though.
<P>

<HR>

<A NAME="energy">
<H2>Energy</H2>
Energy is an attribute of each organism. The total amount of energy in a simulation is
equal to the amount of energy that the first organism(s) had when the simulation was
created. The total energy never changes during a simulation (conservation of energy).
<P>
Every organism must maintain at least <B>one</B> unit of energy just to be considered "alive".
If some operation causes this value to go to zero, the organism is dead.
<P>

<H3>Why Energy?</H3>
The purpose of energy is to introduce a limit on stack growth. Without it, a mutated organism could
just fill up its call stack (or data stack) with junk values and not care about being stack friendly.
<P>
I like to think of "energy" as the 3rd dimension of the simulation. When you specify the universe
you give it a width and height. Energy is like the depth of the sim. If you were to view the
universe in three dimensions then energy would be the depth component. It would form a bumpy surface.
Some grids would contains lots of energy and some grids would contains none (empty squares). But
the maximum depth would remain constant (whatever the starting energy was).
<P>

<H3>No Cost Stack</H3>
Each cell gets <B>fifty</B> "no cost" stack elements. These 50 free stack element are
shared between the data and call stacks. Once a cell increases its total stack usage past <B>50</B>,
then it will require <B>one</B> unit of energy for each new stack element. This energy is withdrawn
from the organisms 'energy' account. If a cell tries to use additional
stack space and the organism does not have enough energy, then that cell is flagged as DEAD.
<p>
When a cell dies in this fashion, it is removed from the organism (and connectivity checks are performed)
and all stack elements past the 50th element, are converted back int energy and returned to the
organisms energy account.
<P>

<H3>Example</H3>
For example, assume the cell is using 55 stack elements (25 data and 30 call stack elements). Assume
the organism has the minimum of 1 unit of energy. Now the cell tries to push "-3" on its data stack.
This causes the organisms energy account to reach "0", which is not allowed (organisms must
maintain a minimum of 1 unit of energy). The cell that causes the organisms energy to dip below
1, will be killed off.
<P>
As a result of the cells attempt to push "-3" on the stack, the cell is killed and the extra
stack elements are converted to energy and returned to the organism. In this case, 5 units of
energy are added back to the organism (55 - 50 = 5).
<P>
So after this cell is killed the organism will have a total energy of 6. (1 + 5 = 6).
<P>

<H3>Energy and Organic Material</H3>
When a cell is killed by being eaten, the connectivity algorithm must analyse the organism and kill of
all but the largest region. Each cell in a region that is killed off will be converted
to organic material. The amount of energy that this organic material will contain is equal to
1/n th the amount of energy in the organism (where n is the number of cells in the organism)
plus any stack elements beyond 10.
<P>
For example, a cell, that is using 53 stack elements, happens to be in a region that is to be killed off.
The organism (which consists of 20 cells) has 100 units of energy. If this cell gets converted
to organic material then it will be given: 3 + 100 * 1/20 units of energy. Or 8.
<P>

<H3>Energy and Spores</H3>
A spore gets created with an energy amount (specified by the MAKE-SPORE instruction). If a spore
gets eaten then this energy amount is transferred to the organism that ate it. If a spore
is fertilized, then the new organism gets created with the sum of energy from the first
and second MAKE-SPORE instructions.
<P>

<H3>Energy and Other Operations</H3>
Energy is not needed to move, look, eat, etc.... Energy is only needed to increase a cells
stack usage beyond fifty (also each organism needs at least one unit of energy to be considered alive).
<P>
Use energy to control the overall population of your simulation:
<UL>
<LI>10,000 units of energy equals about 1,000 organisms.
<LI>40,000 units of energy equals about 4,000 - 6,000 organisms.
<LI>50,000 units of energy equals about 8,000 - 10,000 organisms.
</UL>
<P>
Of course the other factor in population is the width x height of the universe. A bigger
universe will give more room for more organisms.
<P>

<HR>

<A NAME="omove">
<H2>OMOVE</H2>
The <B>OMOVE</B> instruction causes the entire organism to move in one of the 8 directions.
<P>
<IMG BORDER=2 SRC="omove1.gif">
<P>
Assume that cell 2 has executed the instruction <B>1 0 OMOVE</B>. The vector (1,0)
means move right 1 square.
<P>
<IMG SRC="omove2.gif">
<P>
Or assume that cell 1 has executed the instruction <B>-1 1 OMOVE</B>. The vector (-1, 1)
means move left and down diagonally.
<P>
<IMG SRC="omove3.gif">
<P>
The OMOVE instruction first checks that all squares that organism will move to, are
vacant.
<P>

<HR>

<A NAME="rotate">
<H2>ROTATE</H2>
The ROTATE instruction causes the organism to be rotated. Because of the grid layout and
the constraints on the shape of organisms, this instruction only rotates in 90 degree units.
Rotate takes a single integer off of the data stack. This value represents 90 degree rotations.
<P>
Consider this organism, the cell with the <B>dot</B> will execute a ROTATE instruction.
<P>
<IMG BORDER=2 SRC="rotate1.gif">
<P>
Here's what the organism looks like after a <B>-1 ROTATE</B>:
<P>
<IMG BORDER=2 SRC="rotate2.gif">
<P>
Here's what the organism looks like after a <B>1 ROTATE</B> (from starting figure):
<P>
<IMG BORDER=2 SRC="rotate3.gif">
<P>
This instruction requires that all grid locations that the rotated organism is to be moved
are vacant.

<HR>

<A NAME="cmove">
<H2>CMOVE</H2>
CMOVE is a cool instruction. It allows a cell to move relative to the organism.
The following pictures will demonstrate an organism morphing from one shape to
another. The following instructions will be executed:
<PRE>
	0 1 CMOVE	; cell 1 executes this instruction
	0 1 CMOVE	; then cell 4 executes this instruction
	1 -1 CMOVE	; then cell 5 executes this instruction
</PRE>

<P>
<IMG SRC="cmove1.gif">
<P>
<PRE>
	0 1 CMOVE	; <--- cell 1 executes this
</PRE>
<P>
<IMG SRC="cmove2.gif">
<P>
<PRE>
	0 1 CMOVE	; <--- cell 4 executes this
</PRE>
<P>
<IMG SRC="cmove3.gif">
<P>
<PRE>
	1 -1 CMOVE	; <--- cell 5 executes this
</PRE>
<P>
Notice that cell 5 moved diagonally! This is perfectly fine, as long
as the organism is properly connected after the move.
<P>
<IMG SRC="cmove4.gif">
<P>
This last pictures shows what the creature looks like after these 3 CMOVE
instructions.
<P>

<HR>

<A NAME="grow">
<H2>GROW</H2>
<P>
The GROW instruction is how an organism (which always starts out life as a single
cell) becoms multi-cellular.
<P>
Let's assume this is our organism:
<P>
<IMG SRC="grow1.gif">
<P>
To get to the state shown below several possibilities exist:
<PRE>
	1 1 GROW ; executed by cell 2 or,
	1 0 GROW ; executed by cell 3
</PRE>
<P>
<IMG SRC="grow2.gif">
<P>
Another GROW operation produces the organism below.
What are the possible operations that could create the organism?
Here are the only possibilities:
<PRE>
	0  1 GROW	; executed by cell 3 or,
	-1 1 GROW	; executed by cell 4
</PRE>
<P>
<IMG SRC="grow3.gif">
<P>
As shown above, the GROW operation creates a new cell. The new cell recieves
the execution context of the cell that executed the GROW instruction. The
only difference is the new cell has a <B>-1</B> on top of its
data stack and the other cell has a <B>1</B>.
<P>
Grow is very much like the <TT>fork()</TT> system call on Unix. Fork
creates a new process. But fork does it by cloning the current process.
The only way for a programmer to know which execution context they are in
is by examining the return value of fork(). The same applies to the
<TT>GROW</TT> instruction.
<P>
Grow also allows a creature to increase its processing power. An organism consisting
of two cells has twice the processing power of a single celled creature.
Such an organism can do twice the computations in the same amount of steps
as a single celled creature. This is profound capability and any creature that
makes the leap into multi-cellularism has a lot going for it.
<P>
Example KFORTH code using GROW,
<P>
<CENTER><TABLE BORDER=1 BGCOLOR="#F9FBDE" WIDTH="70%"><TR><TD ALIGN=LEFT><PRE>

main:
{
	1 0 GROW -1 = LeafCell if

	brain call
}

LeafCell:
{
   1 0 EAT pop
   -1 -1 EAT pop
   1 ?loop
}

brain:
{
  ; ... creature brain goes here ...
}

</PRE></TD></TABLE></CENTER>

<P>
In this example a new cell is grown at coordinates (1, 0), and the new cell
begins its life executing inside of the code block 'LeafCell'. The LeafCell just eat's
forever. The parent cell continues to call the 'brain' routine to do the normal
creature processing.

<P>
You can write your routine to encapsulate this common logic as follows:
<P>
<CENTER><TABLE BORDER=1 BGCOLOR="#F9FBDE" WIDTH="70%"><TR><TD ALIGN=LEFT><PRE>

main:
{
	1 0 LeafCell myGROW call
	brain call
}

LeafCell:
{
    ; .... leaf cell stuff here ...
}

brain:
{
    ; ... brain cell stuff here ...
}

;
; (x y cb -- )
;
; Grow and call 'cb' for the new cell
;
myGROW:
{
	-rot GROW -1 = { pop } ifelse
}

</PRE></TD></TABLE></CENTER>

<P>
<HR>
<P>

<A NAME="make-spore">
<H2>MAKE-SPORE</H2>
The MAKE-SPORE instruction is how reproduction occurs. In order to reproduce
a spore must be created. But this isn't enough. Another spore must be
created on top of the first one.
<P>
This mechanism allows both sexual and asexual reproduction. (see <A HREF="spores.html">spores</A> for more information). The following example shows an organism reproducing asexually:
<P>
<P>
<IMG SRC="makespore1.gif">
<P>
So our happy organism wants to have a baby. Either cell 2 executes this instruction:
<PRE>
	1 0 20 MAKE-SPORE  ; create spore with 20 units of energy
</PRE>
<P>
Or cell 3 executes this one:
<PRE>
	1 -1 20 MAKE-SPORE  ; create spore with 20 units of energy
</PRE>
<P>
In either case this is what the universe now looks like:
<P>
<IMG SRC="makespore2.gif">
<P>
Now lets assume one of the following instructions gets executed:
<PRE>
	1  0 12 MAKE-SPORE  ; cell 2 does this or....
	1 -1 12 MAKE-SPORE  ; cell 3 does this
</PRE>
<P>
<IMG SRC="makespore3.gif">
<P>
A new organism is born! Whooo hoo. The new organism will start out life
with a modest 32 units of energy (20 + 12).
The new organism will inherit the genetic program of the parent organism
(of course it may have slight mutations).
<P>
<i>Sexual</i> reproduction occurs when two different organisms contribute a spore. In
this case the genetic program from both parents is interlaced (this process is
described elsewhere).
<P>
All organisms belong to a certain strain (by default strain 0). Strains allow you to
tag a lineage of organisms from the first one to an evolved population. Therefore, SPORE's
cannot be fertilized if the two organisms belong to different strains.
<P>
The first MAKE-SPORE operation must have an energy amount that is greather than 0. But the
second MAKE-SPORE instruction can fertilize an existing spore using 0 energy.
<P>

<P>
<HR>
<P>

<A NAME="eat">
<H2>EAT</H2>
Eating is how an organism survives. The EAT instruction must be called to eat
stuff that is touching the cell. The cell executing the EAT instruction
will attempt to eat anything at the (x, y) offset.
<P>
In this example cell 2, executes the <B>1 1 EAT</B> instruction.
<P>
<IMG SRC="eat1.gif">
<P>
After the instruction the white square (organic material) has
been removed.
<P>
<IMG SRC="eat2.gif">
<P>
Not shown is what happens when a cell tries to eat another living cell. In this
case the cell being eaten is flagged as dead (it will show up RED). The organism
which has dead cells will have to resolve that issue later in the simulation.
<P>
To eat the spore located at (0, 1) this instruction could be used: <B>0 1 EAT</B>.
<P>

<P>
<HR>
<P>

<A NAME="look">
<H2>LOOK</H2>
The LOOK instruction takes a normalized (x, y) vector and looks along that
line until it finds something. The thing it finds (the 'what' value) and the distance
in which it was found it returned on the data stack.
<P>
<IMG BORDER=1 SRC="look2.gif">
<P>
This figure shows all 8 direction vectors from a single cell.
The LOOK instruction would return the following for this cell:
<PRE>
	 0 -1 LOOK	; what = 8, where = 100
	 1 -1 LOOK	; what = 2, where = 3
	 1  0 LOOK	; what = 1, where = 2
	 1  1 LOOK	; what = 8, where = 4
	 0  1 LOOK	; what = 4, where = 3
	-1  1 LOOK	; what = 8, where = 4
	-1  0 LOOK	; what = 2, where = 7
	-1 -1 LOOK	; what = 4, where = 3

	 0  0 LOOK      ; what = 0, where = 0
</PRE>
<P>
Vision using LOOK (and the other vision instructions) will look through the organism itself. This
makes the vision instructions less evolutionary brittle, as an "eye" cell can evolve inside the middle
of a multi-cellular organism.
<P>
The 'what' values are powers of 2, which allows them to be OR'd together for form a search mask
(see NEAREST and FARTHEST).
<P>
A LOOK operation using the vector (0, 0) returns a what=0, where=0.
<P>
"What" values are assigned according to this key:
<UL>
<LI> 1 = Cell
<LI> 2 = Spore
<LI> 4 = Organic Material
<LI> 8 = Barrier
</UL>
<P>


<HR>

<A NAME="what">
<H2>WHAT</H2>
<P>
WHAT returns the type of thing seen along a direction vector.
It is a shorthand for these instructions:
<P>
<CENTER><TABLE BORDER=1 BGCOLOR="#F9FBDE" WIDTH="70%"><TR><TD ALIGN=LEFT><PRE>

   LOOK pop

</PRE></TD></TABLE></CENTER>
<P>

<P>
<HR>
<P>

<A NAME="where">
<H2>WHERE</H2>
WHERE returns the distance to something along a direction vector.
It is a shorthand for these instructions:
<P>
<CENTER><TABLE BORDER=1 BGCOLOR="#F9FBDE" WIDTH="70%"><TR><TD ALIGN=LEFT><PRE>

   LOOK swap pop

</PRE></TD></TABLE></CENTER>
<P>

<P>
<HR>
<P>

<A NAME="nearest">
<H2>NEAREST</H2>
This instruction looks in all 8 directions surrounding a cell and returns the (x, y) vector that
has the smallest distance.
<P>
This instruction takes a bit-mask which is an OR'ing of 'what' values. Only these types of
things will be used when determining the nearest direction.
<P>
For example, a mask value of 5 (binary 0101), matches Cells and Organics (but not spores or barriers).
So this code,
<P>
<IMG BORDER=1 SRC="look2.gif">
<P>
<CENTER><TABLE BORDER=1 BGCOLOR="#F9FBDE" WIDTH="70%"><TR><TD ALIGN=LEFT><PRE>

   5 NEAREST	; returns (1, 0)

</PRE></TD></TABLE></CENTER>
<P>
Would return vector (1, 0) because that direction has a "cell" at distance 2 (which is the
smallest distance that matches the bit-mask).
<P>
<B>NOTE:</B> If more than one direction "tie" for seeing the nearest (or farthest)
thing, then instructions NEAREST, FARTHEST, NEAREST2, FARTHEST2 will resolve the tie by
choosing one of the matches randomly.

<P>
<HR>
<P>

<A NAME="farthest">
<H2>FARTHEST</H2>
This instruction looks in all 8 directions surrounding a cell and returns the (x, y) vector that
has the largest distance.
<P>
This instruction takes a bit-mask which is an OR'ing of 'what' values. Only these types of
things will be used when determining the farthest direction.
<P>
For example, a mask value of 2 (binary 0010), matches only spores (but nothing else).
So this code,
<P>
<IMG BORDER=1 SRC="look2.gif">
<P>
<CENTER><TABLE BORDER=1 BGCOLOR="#F9FBDE" WIDTH="70%"><TR><TD ALIGN=LEFT><PRE>

   2 FARTHEST	; returns (-1, 0)

</PRE></TD></TABLE></CENTER>
<P>
Would return vector (-1, 0) because that direction has a "spore" at distance 7 (which is the
largest distance to any spore).

<P>
<HR>
<P>

<A NAME="nearest2">
<H2>NEAREST2</H2>
This instruction looks in all 8 directions surrounding a cell and returns the (x, y) vector that
has the smallest distance.
<P>
This instruction takes a bit-mask which is an OR'ing of 'what' values. Only these types of
things will be used when determining the nearest direction. It also takes a distance value
which limits the search radius.
<P>
For example, a mask value of 8 (binary 1000), matches Barriers (but nothing else).
So this code,
<P>
<IMG BORDER=1 SRC="look2.gif">
<P>
<CENTER><TABLE BORDER=1 BGCOLOR="#F9FBDE" WIDTH="70%"><TR><TD ALIGN=LEFT><PRE>

   8 3 NEAREST2	; returns (0, 0)

</PRE></TD></TABLE></CENTER>
<P>
Would return vector (0, 0) because there are no barriers within the search distance of '3'.

<P>
<HR>
<P>

<A NAME="farthest2">
<H2>FARTHEST2</H2>
This instruction looks in all 8 directions surrounding a cell and returns the (x, y) vector that
has the largest distance.
<P>
This instruction takes a bit-mask which is an OR'ing of 'what' values. Only these types of
things will be used when determining the farthest direction. It also takes a distance value
which limits the search radius.
<P>
For example, a mask value of 2 (binary 0010), matches only spores (but nothing else).
So this code,
<P>
<IMG BORDER=1 SRC="look2.gif">
<P>
<CENTER><TABLE BORDER=1 BGCOLOR="#F9FBDE" WIDTH="70%"><TR><TD ALIGN=LEFT><PRE>

    2 3 FARTHEST2	; returns (1, -1)

</PRE></TD></TABLE></CENTER>
<P>
Would return vector (1, -1) because that direction has a "spore" at distance 3 (which is the
largest distance to any spore within our search radius of '3'). The other spore doesn't match
because it is outside our search radius.

<P>
<HR>
<P>

<!-- ********************  BEGIN CUT/PASTE latest reference data here ******************** -->
<A NAME="reference">
<H2>ORGANISM INSTRUCTION REFERENCE</H2>
The core KFORTH instruction (like dup, pop, +, *, /, etc..) are covered
in the section entitled <A HREF="kforth.html#reference">the KFORTH Language</A>.
What follows is a detailed reference guide for the instructions that control organisms and cells:
<P>

<H3>Interacting with the universe:</H3>
<UL>
<LI> <A HREF="#ref_OMOVE"><B>OMOVE</B></A>
<LI> <A HREF="#ref_ROTATE"><B>ROTATE</B></A>
<LI> <A HREF="#ref_CMOVE"><B>CMOVE</B></A>
<LI> <A HREF="#ref_EAT"><B>EAT</B></A>
<LI> <A HREF="#ref_MAKE-SPORE"><B>MAKE-SPORE</B></A>
<LI> <A HREF="#ref_GROW"><B>GROW</B></A>
</UL>

<H3>Vision:</H3>
<UL>
<LI> <A HREF="#ref_LOOK"><B>LOOK</B></A>
<LI> <A HREF="#ref_WHAT"><B>WHAT</B></A>
<LI> <A HREF="#ref_WHERE"><B>WHERE</B></A>
<LI> <A HREF="#ref_NEAREST"><B>NEAREST</B></A>
<LI> <A HREF="#ref_FARTHEST"><B>FARTHEST</B></A>
<LI> <A HREF="#ref_NEAREST2"><B>NEAREST2</B></A>
<LI> <A HREF="#ref_FARTHEST2"><B>FARTHEST2</B></A>
</UL>

<H3>Communicating between cells:</H3>
<UL>
<LI> <A HREF="#ref_MOOD"><B>MOOD</B></A>
<LI> <A HREF="#ref_MOOD!"><B>MOOD!</B></A>
<LI> <A HREF="#ref_BROADCAST"><B>BROADCAST</B></A>
<LI> <A HREF="#ref_SEND"><B>SEND</B></A>
<LI> <A HREF="#ref_RECV"><B>RECV</B></A>
</UL>

<H3>Query information about ourselves:</H3>
<UL>
<LI> <A HREF="#ref_ENERGY"><B>ENERGY</B></A>
<LI> <A HREF="#ref_AGE"><B>AGE</B></A>
<LI> <A HREF="#ref_NUM-CELLS"><B>NUM-CELLS</B></A>
<LI> <A HREF="#ref_HAS-NEIGHBOR"><B>HAS-NEIGHBOR</B></A>
</UL>

<P>
<HR>
<P>


<A NAME="ref_OMOVE">
<H2>OMOVE</H2>
<B>Usage:</B> ( x y -- r )<P>
Move entire organism by 1 square in the up, down, left, right, or diagonal direction.
<P>
<OL>
<LI> If there are not 2 elements on the data stack, then skip this instruction.
<LI> Remove the (x, y) coordinates from the stack.
<LI> Normalize the coordinates.
<LI> Examine every square that we may be moving to to make sure it is empty, or contains one of our cells.
<LI> If the move is possible, reposition every cell in our organism by the (x, y) offset.
<LI> A move using vector (0, 0) always fails, and returns 0.
</OL>
<P>
<B>RETURNS:</B>
<UL>
<LI> <B>0</B> - move failed.
<LI> <B>1</B> - move was successful.
</UL>
<P>
<B>ENERGY:</B> Does not require any energy.

<P>
<HR>
<P>

<A NAME="ref_ROTATE">
<H2>ROTATE</H2>
<B>Usage:</B> ( n -- r )<P>
Rotate the organism by 90 degree units around the cell that executes
this instruction.
<P>
<OL>
<LI> If there is not 1 element on the data stack, then skip this instruction.
<LI> Remove the rotation amount n from the stack.
<LI> Translate all cells in the organism to the new location, and check that
the spot is vacant (or contains cells from this organism). If not, return 0.
<LI> Else, rotate organism and return 1.
<LI> A rotation value of <B>0</B> always fails, and returns 0.
</OL>
<P>
<B>RETURNS:</B>
<UL>
<LI> <B>0</B> - organism could not be rotated.
<LI> <B>1</B> - success.
</UL>
<P>
<B>ENERGY:</B> Does not require any energy.

<P>
<HR>
<P>

<A NAME="ref_CMOVE">
<H2>CMOVE</H2>
<B>Usage:</B> ( x y -- r )<P>
Move the cell that executes this instruction relative to the organism.
<P>
<OL>
<LI> If there are not 2 elements on the data stack, then skip this instruction.
<LI> Remove the (x, y) coordinates from the stack.
<LI> Normalize the coordinates.
<LI> Examine the destination square (as indicated by the offsets) and see if it
is vacant. If not, return 0.
<LI> Check that the organism is propery connected after the move. If not return 0.
<LI> Else, Move the cell to the new location and return 1.
<LI> A CMOVE of (0,0) always fails and returns <B>0</B>.
</OL>
<P>
<B>RETURNS:</B>
<UL>
<LI> <B>0</B> - cell could not be moved.
<LI> <B>1</B> - success.
</UL>
<P>
<B>ENERGY:</B> Does not require any energy.

<P>
<HR>
<P>

<A NAME="ref_EAT">
<H2>EAT</H2>
<B>Usage:</B> ( x y -- n )<P>
Eat stuff at (x, y) from this cell. Return 'n' the amount of energy eaten.
<P>
<OL>
<LI> Normalize the (x, y) coordinates.
<P>
<LI> Try to eat whatever is at this location:

<LI> Organic material (white squares) will be eaten and all its energy transferred
	to this organism.
	<P>

<LI> Spores (blue squares) will be eaten and all their energy transferred to this organism.
	Even spores created by this organism will be eaten (so be careful!).
	<P>

<LI> Living tissue from other creatures will be eaten:
	<P>

<UL>
<LI> The living tissue must be from ANOTHER organism, not itself.
	The cell cannot eat itself!
	<P>

<LI> The cell being eaten must not already be flagged as dead (not already red).
	<P>

<LI> The cell being eaten is then flagged as dead (red square).
	<P>

<LI> All stack elements from this cell will be converted to energy and trasnferred to
	this organism.
	<P>

<LI> 1/x units of energy (where x is the number of cells in the organism being eaten)
	will be removed from the organism we ate, and transferred to this organism.
	<P>

<LI> any remainder from the integer "1/x" calculation is also removed from the organism
	we ate and transferred to us.
	<P>
</UL>

</OL>
<P>
<B>RETURNS:</B>
<UL>
<LI> <B>0</B> - nothing was eaten
<LI> <B>n</B> - the amount of energy we were able to eat.
</UL>
<P>
<B>ENERGY:</B> Will transfer energy from eaten items to this organism.

<P>
<HR>
<P>

<A NAME="ref_MAKE-SPORE">
<H2>MAKE-SPORE</H2>
<B>Usage:</B> ( x y e -- r )<P>
Create new spore (or fertilize and existing spore).
<P>
<OL>
<LI> If there are not 3 elements on the data stack, then skip this instruction.
<LI> Remove energy 'e' from the stack. (this is the amount of energy that this
	organism will give up and transfer to the new spore).
<LI> Remove the (x, y) coordinates from the stack.
<LI> Normalize the coordinates.
<LI> For new spores, if energy 'e' is less than or equal to 0, then return 0.
<LI> For fertilizing an existing spore, if energy 'e' is less than 0, then return 0.
<LI> If energy 'e' is more than the amount of energy this organism has, then return 0.

<LI> If the location indicated by the normalized (x, y) coordinates is not blank
		or is not a spore, then return 0.

<LI> If the location is blank, then create the first spore. Transfer 'e' units of
	energy from this organism and give it to the new spore. Return 1.

<LI> If the location is a spore (<B>and the strain # of the organism that created this spore
	is the same as our strain</B>), then fertilize the
	existing spore. Transfer 'e' units of energy from this organism to the fertilized
	spore. Return -1.

<LI> If the strain numbers do not match, then the spore will not be fertilized
	and <B>0</B> will be returned on the data stack.

<LI> If the organism is a sex-only creature (specified with a <B>xy*99</B> string) then
	this instruction will fail (and return <B>0</B>) if the organism attempts to fertilize
	a spore itself created. See the section <A HREF="xy_simulations.html">XY Simulations</A>
	for more information.

</OL>
<P>
<B>RETURNS:</B>
<UL>
<LI> <B>0</B> - could not make spore.
<LI> <B>1</B> - created spore.
<LI> <B>-1</B> - fertilized existing spore.
</UL>
<P>
<B>ENERGY:</B> Requires 'e' units of energy.

<P>
When a spore is fertilized, the original genetic program used to create the
spore, and the genetic program from the organism that fertilized the spore will be
first merged. Then the resulting genetic program is MUTATED. Then a new organism
is born. It will begin execution at the first instruction of code block 0 (main). It
will be given 'e' units of energy, which is the sum of the energy specified with
the first and second MAKE-SPORE instructions.

<P>
<HR>
<P>

<A NAME="ref_GROW">
<H2>GROW</H2>
<B>Usage:</B> ( x y -- r )<P>
Add a new cell to this organism.
<P>
<OL>
<LI> If there are not 2 elements on the data stack, then skip this instruction.

<LI> Remove the (x, y) coordinates from the stack.

<LI> Normalize the coordinates.

<LI> If the location specified by the coordinates is not blank, then return 0.

<LI> Compute the amount of energy needed to grow (this is the sum of
	the data stack size and the call stack size).

<LI> If organims does not have enough energy to GROW a new cell, then return 0.

<LI> If the location specified is not "touching" the organism in the up, down,
	left or right direction, then return 0.

<LI> Create new cell at location specified. Clone this cells data
	and call stack (as well as registers, and so on).

<LI> Subtract the stack sizes from this organisms energy account.

<LI> For the cell executing the GROW instruction return 1.

<LI> For the new cell, just created, make it appear as if it returned -1.

</OL>
<P>
<B>RETURNS:</B>
<UL>
<LI> <B>0</B> - could not grow
<LI> <B>1</B> - grow succeeded (the cell that executed the GROW instruction)
<LI> <B>-1</B> - grow succeeded (the new cell)
</UL>
<P>
<B>ENERGY:</B> Requires (c.data_stack_size + c.call_stack_size + 1) units of energy.
	(where 'c' is the cell executing the GROW instruction). The "+ 1" is for
	the return value that we will place on the new cells data stack.
<P>
<HR>
<P>

<A NAME="ref_LOOK">
<H2>LOOK</H2>
<B>Usage:</B> ( x y -- what where )<P>
Look along a normalized (x, y) direction vector. Return the thing it found, and the distance.
<P>
<OL>
<LI> If there are not 2 elements on the data stack, then skip this instruction.

<LI> Remove the (x, y) coordinates from the stack and normalize the coordinate.

<LI> Look along the direction vector until something is found (or the edge of the
universe is reached).

<LI> Ignore any cell that happens to be from the same organism as us.

<LI> Push the type of thing ('what' value) on the data stack. (WHAT value Key: 1=cell,
	2=spore, 4=organic material, 8=barrier).

<LI> Push the distance ('where' value) on the data stack. A distance of 1 means
    the thing seen is touching this cell.

</OL>
<P>
<B>RETURNS:</B>
<UL>
<LI> <B>what where</B> - before reaching the end of the vector something was found. "something"
	is one of ORGANIC MATERIAL, SPORE, or living cell.

<LI> <B>0 0</B> - when then (x, y) vector was (0, 0).
</UL>
<P>
<B>ENERGY:</B> Does not use energy.

<P>
<HR>
<P>

<A NAME="ref_WHAT">
<H2>WHAT</H2>
<B>Usage:</B> ( x y -- what )<P>
<P>
WHAT returns the type of thing seen along a direction vector.
It is a shorthand for these instructions:
<P>
<CENTER><TABLE BORDER=1 BGCOLOR="#F9FBDE" WIDTH="70%"><TR><TD ALIGN=LEFT><PRE>

    LOOK pop

</PRE></TD></TABLE></CENTER>
<P>

<P>
<B>RETURNS:</B>
<UL>
<LI> <B>0</B> - no spore seen along this vector.
<LI> <B>distance</B> - before reaching the end of the vector a spore was found.
</UL>
<P>
<B>ENERGY:</B> Does not use energy.

<P>
<HR>
<P>

<A NAME="ref_WHERE">
<H2>WHERE</H2>
<B>Usage:</B> ( x y -- where )<P>
WHERE returns the distance to something along a direction vector.
It is a shorthand for these instructions:
<P>
<CENTER><TABLE BORDER=1 BGCOLOR="#F9FBDE" WIDTH="70%"><TR><TD ALIGN=LEFT><PRE>

   LOOK swap pop

</PRE></TD></TABLE></CENTER>
<P>

<P>
<HR>
<P>

<A NAME="ref_NEAREST">
<H2>NEAREST</H2>
<B>Usage:</B> ( mask -- x y )<P>
Looks in all 8 directions and return the (x, y) direction vector that corresponds
to the thing with the smallest distance (and matches a 'mask' value).
<P>
<OL>
<LI> If there is not 1 element on the data stack, then skip this instruction.
<LI> remove 'mask' value from data stack.
<LI> strip all bits from the mask, except first 4 bits (e.g. 000001111)
<LI> if mask bits are all 0, then return the vector (0, 0)
<LI> Look in all 8 directions, beginning with a RANDOM direction and proceeding in
	a clock-wise direction.
<LI> Keep track of the closest thing seen (whose 'what' value is set in the bit-mask)
<LI> Return the (x, y) direction vector.
<LI> If nothing matched the bit-mask, then (0, 0) is returned.
</OL>
<P>
<B>RETURNS:</B>
<UL>
<LI> <B>x y</B> - the direction vector that is nearest and matches the 'mask'
<LI> <B>0 0</B> - nothing matched the 'mask'
</UL>
<P>
<B>ENERGY:</B> Does not use energy.

<P>
<HR>
<P>

<A NAME="ref_FARTHEST">
<H2>FARTHEST</H2>
<B>Usage:</B> ( mask -- x y )<P>
Looks in all 8 directions and return the (x, y) direction vector that corresponds
to the thing with the largest distance (and matches a 'mask' value).
<P>
<OL>
<LI> If there is not 1 element on the data stack, then skip this instruction.
<LI> remove 'mask' value from data stack.
<LI> strip all bits from the mask, except first 4 bits (e.g. 000001111)
<LI> if mask bits are all 0, then return the vector (0, 0)
<LI> Look in all 8 directions, beginning with a RANDOM direction and proceeding in
	a clock-wise direction.
<LI> Keep track of the farthest thing seen (whose 'what' value is set in the bit-mask)
<LI> Return the (x, y) direction vector.
<LI> If nothing matched the bit-mask, then (0, 0) is returned.
</OL>
<P>
<B>RETURNS:</B>
<UL>
<LI> <B>x y</B> - the direction vector that is farthest and matches the 'mask'
<LI> <B>0 0</B> - nothing matched the 'mask'
</UL>
<P>
<B>ENERGY:</B> Does not use energy.

<P>
<HR>
<P>

<A NAME="ref_NEAREST2">
<H2>NEAREST2</H2>
<B>Usage:</B> ( mask dist -- x y )<P>
Looks in all 8 directions and return the (x, y) direction vector that corresponds
to the thing with the smallest distance (and matches a 'mask' value and is within
the distance search radius).
<P>
<OL>
<LI> If there are not 2 elements on the data stack, then skip this instruction.
<LI> remove 'mask' value from data stack.
<LI> remove 'dist' value from data stack.
<LI> strip all bits from the mask, except first 4 bits (e.g. 000001111)
<LI> if mask bits are all 0, then return the vector (0, 0)
<LI> if 'dist' is 0 or less, then return the vector (0, 0)
<LI> Look in all 8 directions, beginning with a RANDOM direction and proceeding in
	a clock-wise direction.
<LI> Keep track of the closest thing seen (whose 'what' value is set in the bit-mask
	and whose distance is less then or equal to 'dist').
<LI> Return the (x, y) direction vector.
<LI> If nothing matched the bit-mask or was within the search radius, then return (0, 0).
</OL>
<P>
<B>RETURNS:</B>
<UL>
<LI> <B>x y</B> - the direction vector that is nearest and matches the 'mask'
<LI> <B>0 0</B> - nothing matched the 'mask'
</UL>
<P>
<B>ENERGY:</B> Does not use energy.

<P>
<HR>
<P>

<A NAME="ref_FARTHEST2">
<H2>FARTHEST2</H2>
<B>Usage:</B> ( mask dist -- x y )<P>
Looks in all 8 directions and return the (x, y) direction vector that corresponds
to the thing with the smallest distance (and matches a 'mask' value and is within
the distance search radius).
<P>
<OL>
<LI> If there are not 2 elements on the data stack, then skip this instruction.
<LI> remove 'mask' value from data stack.
<LI> remove 'dist' value from data stack.
<LI> strip all bits from the mask, except first 4 bits (e.g. 000001111)
<LI> if mask bits are all 0, then return the vector (0, 0)
<LI> if 'dist' is 0 or less, then return the vector (0, 0)
<LI> Look in all 8 directions, beginning with a RANDOM direction and proceeding in
	a clock-wise direction.
<LI> Keep track of the farthest thing seen (whose 'what' value is set in the bit-mask
	and whose distance is less then or equal to 'dist').
<LI> Return the (x, y) direction vector.
<LI> If nothing matched the bit-mask or was within the search radius, then return (0, 0).
</OL>
<P>
<B>RETURNS:</B>
<UL>
<LI> <B>x y</B> - the direction vector that is farthest and matches the 'mask'
<LI> <B>0 0</B> - nothing matched the 'mask'
</UL>
<P>
<B>ENERGY:</B> Does not use energy.

<P>
<HR>
<P>


<A NAME="cellular_communications">
<H1>Communicating Between Cells</H1>
<P>
<CENTER><IMG SRC="cell_com.gif"></CENTER>
<CENTER><I>Cellular Communications</I></CENTER>

<P>
Refer to this figure for the descriptions of the following instructions.
The <b>mood</b> register is something the cell sets, and others can look at. The <b>message</b> register
is something that others set, and this cell looks at.
<P>
Using the instructions <B>pack2, pack4, unpack2, unpack4</B> many values can be combined into a
single 64-bit integer and stored in the MOOD and MESSAGE registers. For example, to send 4 integers to
another cell, this code could be used:
<P>
<PRE>
	23 -999 5901 3 pack4		; combined these 4 (16-bit intgers) into single 64-bit int.
	-1 1 SEND			; send to cell

</PRE>
<P>
The reciving cell, can extract these 4 values like so:
<P>
<PRE>
	RECV
	unpack4			; the values 23, -999, 5901, 3 are now on the stack
</PRE>

<P>
<HR>
<P>

<A NAME="ref_MOOD">
<H2>MOOD</H2>
<B>Usage:</B> ( x y -- m )<P>
Every cell has its own "MOOD" register. This instruction queries another cell
using an (x, y) vector. This vector <B>is not normalized</B> which allows the cell
to query any other cell within its own organism (not just adjacent cells). For example,
if cell 2 executed the following instructions:
<PRE>
	0 0 MOOD   ; returns -23
	-1 0 MOOD   ; returns 123
	-1 1 MOOD   ; returns 33
	99 99 MOOD   ; returns 0
</PRE>
<P>
If a bogus (x, y) is specified then 0 is pushed on the data stack. (0, 0) refers to the
cell executing the instruction.
<P>
<B>ENERGY:</B> Does not use energy.

<P>
<HR>
<P>

<A NAME="ref_MOOD!">
<H2>MOOD!</H2>
<B>Usage:</B> ( m -- )<P>
The cell executing this instruction will set its own <b>mood</b> register. It is not possible
to set others. The purpose of the <b>mood</b> register is for a cell it advertise its "mood" to
other cells in the organism. For example, if cell 3 executed these instructions:
<PRE>
	0 0 MOOD 1 + MOOD!
</PRE>
Then cell 3's mood would be increased by 1. So it would be set to 34.
<P>
<B>ENERGY:</B> Does not use energy.
<P>
<HR>
<P>

<A NAME="ref_BROADCAST">
<H2>BROADCAST</H2>
<B>Usage:</B> ( m -- )<P>
This instruction takes the value off of the top of the data stack and sets the <b>message</b>
register for every cell in our organism.
<P>
<B>ENERGY:</B> Does not use energy.
<P>
<HR>
<P>

<A NAME="ref_SEND">
<H2>SEND</H2>
<B>Usage:</B> ( m x y -- )<P>
This instruction takes 3 arguments. An (x, y) vector and a value 'm'. The vector <b>is NOT
normalized</b> so that the cell can send a message 'm' to any other cell in the same organism
(not just adjacent cells). For example, if cell 1 exectuted this these two instructions:
<PRE>
	100     1 0 SEND   ; set cell 2's message register to 100
	-46812  0 1 SEND   ; set cell 3's message register to -46812
	0       0 0 SEND   ; set out message register to 0.
	12   -99 99 SEND   ; does nothing because (-99, 99) is bogus
</PRE>

A SEND operation using bogus coordinates will be ignored.
<P>
<B>ENERGY:</B> Does not use energy.
<P>
<HR>
<P>

<A NAME="ref_RECV">
<H2>RECV</H2>
<B>Usage:</B> ( -- m )<P>
The RECV instruction just pushes a copy of our message register on top of
the data stack.
<P>
<B>ENERGY:</B> Does not use energy.
<P>
<HR>
<P>

<A NAME="ref_ENERGY">
<H2>ENERGY</H2>
<B>Usage:</B> ( -- e )<P>
Fetch the organisms "energy" field and place it on our data stack. Please be
aware that putting something on the data stack requires 1 unit of energy. So the
value placed on the data stack is BEFORE the simulator subtracts 1 unit of energy for
the data stack entry.
<P>
Also this instruction does not account for any energy that is stored in the form of stack
elements. (This is a good thing, because such energy is not really available to be used).
<P>
<B>ENERGY:</B> Does not use energy.
<P>
<HR>
<P>

<A NAME="ref_AGE">
<H2>AGE</H2>
<B>Usage:</B> ( -- a )<P>
Fetch the organisms "age" field (which is the number of elapsed simulation step)
and push this value on our data stack.
<P>
<B>ENERGY:</B> Does not use energy.
<P>
<HR>
<P>

<A NAME="ref_NUM-CELLS">
<H2>NUM-CELLS</H2>
<B>Usage:</B> ( -- n )<P>
Push the number of cells that comprise this organism on our data stack.
<P>
<B>ENERGY:</B> Does not use energy.
<P>
<HR>
<P>

<A NAME="ref_HAS-NEIGHBOR">
<H2>HAS-NEIGHBOR</H2>
<B>Usage:</B> ( x y -- r )<P>
<OL>
<LI> On the data stack should be two values. If not, we ignore this instruction.

<LI> The two values are popped off the stack (they are NOT normalized).
	This forms an (x, y) vector that refers to one of our
	nearby grid locations.

<LI> If we have a cell at this (x, y) offset, then this instruction returns 1.
 Else 0 will be returned.

<LI> The vector (0,0) is allowed, and always returns 1.

</OL>
<P>
<B>RETURNS:</B>
<UL>
<LI> <B>1</B> - at offset (x, y) is one of our cells.
<LI> <B>0</B> - at offset (x, y) it NOT one of our cells.
</UL>

<P>
<B>ENERGY:</B> Does not use energy.
<P>
<!-- ******************** END CUT/PASTE latest reference data here ******************** -->

</div>

<div id="footer">
<a href="mailto:ken@stauffercom.com">E-mail</a> | <a href="http://www.stauffercom.com">Home</a>
<br />
&copy; 2006 Ken Stauffer. All rights reserved.
</div>
</body>
</html>
